"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[745],{87835:function(e){e.exports=JSON.parse('{"functions":[{"name":"transition","desc":"Returns a new StateMachine with the post-transition state.","params":[{"name":"eventName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"StateMachine"}],"function_type":"method","source":{"line":77,"path":"src/init.lua"}},{"name":"lock","desc":"Returns a new StateMachine where the event can no longer be triggered.\\n\\n:::note\\nLocking and unlocking is layer-based, which means that locking twice results in 2 layers, thus, to actually\\nunlock the event, you now have to unlock it 2 times.\\n:::","params":[{"name":"eventName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"StateMachine"}],"function_type":"method","source":{"line":107,"path":"src/init.lua"}},{"name":"unlock","desc":"Returns a new StateMachine where the event can be triggered, but only if no lock layer remains.","params":[{"name":"eventName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"StateMachine"}],"function_type":"method","source":{"line":123,"path":"src/init.lua"}},{"name":"IsLocked","desc":"Returns true if there are 1 or more layers of lock for the event.","params":[{"name":"eventName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":141,"path":"src/init.lua"}},{"name":"State","desc":"Returns the state of the machine.","params":[],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":153,"path":"src/init.lua"}},{"name":"Trigger","desc":"Returns the last triggered event wrapped in an option or option.None if no event has been triggerd yet.\\n\\nOption\'s API: https://sleitnick.github.io/RbxUtil/api/Option/","params":[],"returns":[{"desc":"","lua_type":"Option<string>"}],"function_type":"method","source":{"line":167,"path":"src/init.lua"}},{"name":"Can","desc":"Returns true if the event can be triggered based on the machine\'s current state.","params":[{"name":"eventName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":180,"path":"src/init.lua"}}],"properties":[],"types":[],"name":"StateMachine","desc":"An immutable class for handling the state of things, where the design is a copy of Rust\'s sm crate, but with a few additions and changes.\\n\\n```lua\\n-- Returns a function that constructs an object of the StateMachine class based on the control flow map provided.\\nlocal Lock = StateMachine {\\n    TurnKey = {\\n        Locked = \'Unlocked\',\\n        Unlocked = \'Locked\',\\n    },\\n\\n    Break = {\\n        Locked = \'Broken\',\\n        Unlocked = \'Broken\',\\n    },\\n}\\n\\n-- Starts the machine on the \\"Locked\\" state.\\nlocal lock = Lock(\'Locked\')\\nlock = lock:transition(\'TurnKey\')\\n\\nassert(lock:State(), \'Unlocked\')\\nassert(lock:Trigger():Unwrap(), \'TurnKey\')\\n```","source":{"line":55,"path":"src/init.lua"}}')}}]);